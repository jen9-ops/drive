<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Тактична Карта-Навігатор</title>

    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Карта-Навігатор">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    
    <script src="https://unpkg.com/mgrs@2.0.0/mgrs.js"></script>
    
    <style>
        :root {
            --bg-color: rgba(255, 255, 255, 0.85);
            --blur-effect: blur(12px);
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.1);
            --text-color: #2c2c2c;
            --accent-color: #007aff;
            --record-color: #ff3b30;
            --navigation-color: #3478F6;
            --success-color: #34c759;
            --danger-color: #ff3b30;
            --warning-color: #ff9500;
            --transition-speed: 0.3s;
            --main-bg: #eef1f4;
            --icon-shadow: 0 1px 4px rgba(0,0,0,0.5);
            --icon-color-light: #2c2c2c;
            --icon-color-dark: #f5f5f7;
        }

        [data-theme="dark"] {
            --bg-color: rgba(28, 28, 30, 0.85);
            --border-color: rgba(255, 255, 255, 0.15);
            --shadow-color: rgba(0, 0, 0, 0.3);
            --text-color: #f5f5f7;
            --main-bg: #1c1c1e;
            --icon-shadow: 0 1px 4px rgba(0,0,0,0.7);
        }
        
        html, body {
            height: 100%; width: 100%; margin: 0; padding: 0;
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
            background-color: var(--main-bg);
            overflow: hidden; position: fixed;
        }
        
        #map { width: 100%; height: 100%; z-index: 1; }
        .map-routing-mode, .map-navigation-mode { cursor: crosshair !important; }

        .action-button {
            position: absolute; width: 44px; height: 44px;
            background: none; border: none; border-radius: 50%;
            font-size: 24px; cursor: grab;
            color: var(--icon-color-light);
            display: flex; justify-content: center; align-items: center;
            transition: color 0.2s, transform 0.2s;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 1001;
        }
        [data-theme="dark"] .action-button {
            color: var(--icon-color-dark);
            text-shadow: 0 2px 4px rgba(0,0,0,0.7);
        }
        
        .action-button.grabbing { cursor: grabbing; z-index: 1002; }
        .action-button:hover { color: var(--accent-color); transform: scale(1.15); }
        .action-button.active { color: var(--accent-color); }
        .action-button.navigating { color: var(--navigation-color); animation: pulse 1.5s infinite; }
        .action-button.recording { color: var(--record-color); animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }
        
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); z-index: 2500; display: flex;
            justify-content: center; align-items: center; opacity: 0;
            visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content {
            background: var(--bg-color); padding: 25px; border-radius: 12px;
            box-shadow: 0 5px 25px var(--shadow-color); width: 90%; max-width: 400px;
            position: relative; -webkit-backdrop-filter: var(--blur-effect);
            backdrop-filter: var(--blur-effect); max-height: 80vh; overflow-y: auto;
        }
        .modal-content h3 {
            margin-top: 0; border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px; margin-bottom: 15px; color: var(--text-color);
        }
        .modal-close {
            position: absolute; top: 10px; right: 15px; font-size: 28px;
            font-weight: bold; background: none; border: none; cursor: pointer;
            color: var(--text-color); opacity: 0.7; transition: opacity 0.2s;
        }
        .modal-close:hover { opacity: 1; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: 500; font-size: 14px; color: var(--text-color); }
        .form-group input, .form-group button {
            width: 100%; padding: 10px; border: 1px solid var(--border-color);
            background: transparent; color: var(--text-color); border-radius: 6px; font-size: 14px; box-sizing: border-box;
        }
        .modal-submit-button {
            padding: 12px; font-size: 16px; font-weight: 600; border: none;
            background: var(--accent-color); color: white; border-radius: 8px; cursor: pointer;
            margin-top: 15px; transition: background-color 0.2s;
        }

        .notifications { position: fixed; top: 20px; right: 20px; z-index: 10000; max-width: 300px; }
        .notification {
            background: var(--bg-color); border-radius: 8px; padding: 12px 16px; margin-bottom: 10px;
            border-left: 4px solid var(--accent-color); animation: fadeIn 0.3s ease;
            box-shadow: 0 4px 12px var(--shadow-color);
            -webkit-backdrop-filter: var(--blur-effect); backdrop-filter: var(--blur-effect);
        }
        .notification.success { border-left-color: var(--success-color); }
        .notification.error { border-left-color: var(--danger-color); }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        #coords-display {
            position: absolute; bottom: 0; left: 0; z-index: 1000; background: transparent;
            padding: 4px 8px; font-size: 12px; color: var(--text-color);
            text-shadow: 0 0 4px var(--main-bg), 0 0 4px var(--main-bg);
        }
        
        .leaflet-control-zoom { background: transparent !important; border: none !important; box-shadow: none !important; }
        .leaflet-control-zoom-in, .leaflet-control-zoom-out {
            background-color: transparent !important;
            color: var(--icon-color-light) !important;
            border: none !important; box-shadow: none !important;
            width: 44px !important; height: 44px !important; line-height: 44px !important;
            font-size: 24px !important;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5) !important;
        }
         [data-theme="dark"] .leaflet-control-zoom-in, [data-theme="dark"] .leaflet-control-zoom-out {
            color: var(--icon-color-dark) !important;
            text-shadow: 0 2px 4px rgba(0,0,0,0.7) !important;
        }
        
        .leaflet-control-layers { border: 1px solid var(--border-color) !important; background: var(--bg-color) !important; -webkit-backdrop-filter: var(--blur-effect); backdrop-filter: var(--blur-effect); box-shadow: 0 2px 10px var(--shadow-color) !important; color: var(--text-color) !important; border-radius: 8px; }
        .leaflet-routing-container {
            background-color: var(--bg-color) !important; color: var(--text-color) !important; border: 1px solid var(--border-color) !important;
            box-shadow: 0 4px 20px var(--shadow-color) !important; -webkit-backdrop-filter: var(--blur-effect); backdrop-filter: var(--blur-effect);
        }
        
        .list-item {
            padding: 10px; border-bottom: 1px solid var(--border-color); cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(128,128,128,0.1); border-radius: 5px; margin-bottom: 5px;
        }
        .list-item:hover { background: rgba(128,128,128,0.2); }
        .list-item-actions button { background: none; border: none; color: var(--danger-color); cursor: pointer; font-size: 16px; }

        #nav-info-panel {
            position: absolute;
            top: 15px;
            left: 50%;
            z-index: 1000;
            background: var(--bg-color);
            color: var(--text-color);
            padding: 8px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            -webkit-backdrop-filter: var(--blur-effect);
            backdrop-filter: var(--blur-effect);
            box-shadow: 0 2px 8px var(--shadow-color);
            transition: opacity 0.3s, transform 0.3s;
            opacity: 0;
            transform: translate(-50%, -10px); 
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #nav-info-panel.visible {
            opacity: 1;
            transform: translate(-50%, 0);
        }
        #nav-info-panel .separator {
            width: 1px;
            height: 16px;
            background-color: var(--border-color);
        }
        #eta-toggle-btn {
            pointer-events: all;
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        #eta-toggle-btn:hover {
            background-color: var(--border-color);
        }
        #arrival-weather, .eta-info {
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="notifications"></div>
    <div id="coords-display">Lat/Lon: --, --<br>MGRS: --</div>
    <div id="nav-info-panel"></div>

    <div id="action-buttons">
        <button id="theme-btn" class="action-button" title="Змінити тему"><i class="fa-solid fa-moon"></i></button>
        <button id="gps-btn" class="action-button" title="Знайти моє місцеположення"><i class="fa-solid fa-location-crosshairs"></i></button>
        <button id="search-btn" class="action-button" title="Пошук"><i class="fa-solid fa-magnifying-glass"></i></button>
        <button id="weather-btn" class="action-button" title="Погода"><i class="fa-solid fa-cloud-sun"></i></button>
        <button id="routes-btn" class="action-button" title="Мої маршрути"><i class="fa-solid fa-list-check"></i></button>
        <button id="record-btn" class="action-button" title="Запис маршруту"><i class="fa-solid fa-route"></i></button>
        <button id="plan-btn" class="action-button" title="Прокласти маршрут (2 кліки)"><i class="fa-solid fa-diamond-turn-right"></i></button>
        <button id="navigate-btn" class="action-button" title="Навігація"><i class="fa-solid fa-location-arrow"></i></button>
        <button id="install-btn" class="action-button" title="Встановити додаток" style="display: none;"><i class="fa-solid fa-download"></i></button>
    </div>

    <div id="save-route-modal" class="modal-overlay"> <div class="modal-content"><button class="modal-close">&times;</button><h3>Зберегти маршрут</h3><div class="form-group"><label for="route-name-input">Назва:</label><input type="text" id="route-name-input"></div><div class="form-group"><label for="route-color-picker">Колір:</label><input type="color" id="route-color-picker" value="#007aff" style="height: 40px; padding: 0;"></div><p><strong>Дистанція:</strong> <span id="route-distance-display">0.00</span> km</p><div style="display: flex; gap: 10px; margin-top: 20px;"><button id="discard-route-btn" class="modal-submit-button" style="background-color: #8e8e93;">Скасувати</button><button id="save-route-btn" class="modal-submit-button">Зберегти</button></div></div></div>
    <div id="search-modal" class="modal-overlay"><div class="modal-content"><button class="modal-close">&times;</button><h3>Пошук</h3><div class="form-group"><input type="text" id="search-input" placeholder="Введіть адресу або координати..."></div><button id="search-submit-btn" class="modal-submit-button">Знайти</button><div id="search-results" style="margin-top: 15px;"></div></div></div>
    <div id="weather-modal" class="modal-overlay"><div class="modal-content"><button class="modal-close">&times;</button><h3>Погода в центрі карти</h3><div id="weather-details" style="display: flex; flex-direction: column; gap: 8px;"></div></div></div>
    <div id="routes-modal" class="modal-overlay"><div class="modal-content"><button class="modal-close">&times;</button><h3>Мої маршрути</h3><div id="route-list" style="margin-bottom: 20px;"></div><div style="display: flex; gap: 10px;"><button id="import-routes-btn" class="modal-submit-button" style="background-color: #5856d6;">Імпорт</button><button id="export-routes-btn" class="modal-submit-button" style="background-color: #ff9500;">Експорт</button></div></div></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>

    <script>
    // Классы MGRSConverter и Coordinator остаются без изменений
    class MGRSConverter { toMGRS(lat, lng, precision = 5) { try { return mgrs.forward([lng, lat], precision); } catch (error) { console.warn("Помилка перетворення в MGRS:", error); return "Помилка конвертації"; } } parseMGRS(mgrsString) { try { const mgrsPattern = /^\d{1,2}[C-HJ-NP-X]\s*([A-HJ-NP-Z]{2})\s*(\d{2,10})$/i; if (!mgrsPattern.test(mgrsString.replace(/\s/g, ''))) { return null; } const coords = mgrs.inverse(mgrsString); return { lat: coords[1], lng: coords[0] }; } catch (error) { return null; } } }
    class Coordinator { constructor() { this.mgrsConverter = new MGRSConverter(); } toMGRS(lat, lng, precision = 5) { return this.mgrsConverter.toMGRS(lat, lng, precision); } parse(str) { if (!str || typeof str !== 'string') return null; const trimmedStr = str.trim(); const mgrsCoords = this.mgrsConverter.parseMGRS(trimmedStr); if (mgrsCoords) return mgrsCoords; const formats = [ { regex: /^(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)$/, parser: m => ({ lat: parseFloat(m[1]), lng: parseFloat(m[2]) }) }, { regex: /^([NS]?)\s*(-?\d+\.?\d*)\s*[,\s]+\s*([EW]?)\s*(-?\d+\.?\d*)$/i, parser: m => { let lat = parseFloat(m[2]); let lng = parseFloat(m[4]); if (m[1].toUpperCase() === 'S') lat = -lat; if (m[3].toUpperCase() === 'W') lng = -lng; return { lat, lng }; } }, { regex: /^(\d+)°\s*(\d+)'\s*([\d.]+)"\s*([NS])\s*[,\s]+\s*(\d+)°\s*(\d+)'\s*([\d.]+)"\s*([EW])$/i, parser: m => { let lat = parseFloat(m[1]) + parseFloat(m[2])/60 + parseFloat(m[3])/3600; let lng = parseFloat(m[5]) + parseFloat(m[6])/60 + parseFloat(m[7])/3600; if (m[4].toUpperCase() === 'S') lat = -lat; if (m[8].toUpperCase() === 'W') lng = -lng; return { lat, lng }; } } ]; for (const format of formats) { const match = trimmedStr.match(format.regex); if (match) { const result = format.parser(match); if (this.isValid(result.lat, result.lng)) return result; } } return null; } isValid(lat, lng) { return !isNaN(lat) && !isNaN(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180; } }

    class TacticalNavigator {
        constructor() {
            this.map = null;
            this.elements = {};
            this.layers = {};
            this.state = {
                isRecording: false,
                isNavigating: false,
                isPlanning: false,
                deferredPrompt: null,
                sunriseTime: null,
                sunsetTime: null,
                etaTarget: 'sunrise',
                routeWeather: null,
            };
            this.services = {
                coordinator: new Coordinator(),
                recording: { watchId: null, points: [], tempLayer: null },
                navigation: { watchId: null, control: null, marker: null, oneWayDistance: 0, lastKnownSpeed: 0 },
                planning: { control: null, waypoints: [] },
                routes: JSON.parse(localStorage.getItem('savedRoutes') || '[]')
            };
        }
        
        // --- Весь код до функции toggleNavigation остается без изменений ---
        init() { console.log("🚀 Ініціалізація Тактичної Карти-Навігатора..."); this.initMap(); this.initUI(); this.setupEventHandlers(); this._setupPWA(); this.loadTheme(); this.loadSavedRoutes(); this.showNotification('Додаток готовий до роботи!', 'success'); }
        initMap() { this.map = L.map('map', { zoomControl: false }).setView([50.41, 30.64], 11); L.control.zoom({ position: 'bottomright' }).addTo(this.map); this.layers.base = { "Стандартна": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' }), "Супутник": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri' }), }; this.layers.base["Стандартна"].addTo(this.map); this.layers.savedRoutes = L.layerGroup().addTo(this.map); this.layers.mortarRange = L.layerGroup().addTo(this.map); this.services.recording.tempLayer = L.layerGroup().addTo(this.map); L.control.layers(this.layers.base, { "Збережені маршрути": this.layers.savedRoutes, "Зона ураження": this.layers.mortarRange }).addTo(this.map); this.map.on('mousemove', e => this.updateCoordinates(e.latlng)); this.map.on('click', e => this.updateCoordinates(e.latlng)); }
        initUI() { this.elements = { notifications: document.querySelector('.notifications'), coordsDisplay: document.getElementById('coords-display'), navInfoPanel: document.getElementById('nav-info-panel'), modals: { saveRoute: document.getElementById('save-route-modal'), search: document.getElementById('search-modal'), weather: document.getElementById('weather-modal'), routes: document.getElementById('routes-modal'), }, buttons: { install: document.getElementById('install-btn'), theme: document.getElementById('theme-btn'), record: document.getElementById('record-btn'), } }; this._setupDraggableButtons(); }
        setupEventHandlers() { document.getElementById('theme-btn').addEventListener('click', () => this.toggleTheme()); document.getElementById('gps-btn').addEventListener('click', () => this._getGpsLocation()); document.getElementById('search-btn').addEventListener('click', () => this._showModal('search')); document.getElementById('weather-btn').addEventListener('click', () => this.showWeather()); document.getElementById('routes-btn').addEventListener('click', () => this._showModal('routes')); document.getElementById('record-btn').addEventListener('click', () => this.toggleRecording()); document.getElementById('plan-btn').addEventListener('click', () => this.togglePlanning()); document.getElementById('navigate-btn').addEventListener('click', () => this.toggleNavigation()); this.elements.buttons.install.addEventListener('click', () => this._installPWA()); document.querySelectorAll('.modal-overlay').forEach(modal => { modal.addEventListener('click', (e) => { if (e.target === modal) this._hideModal(modal.id.replace('-modal', '')); }); modal.querySelector('.modal-close').addEventListener('click', () => this._hideModal(modal.id.replace('-modal', ''))); }); document.getElementById('save-route-btn').addEventListener('click', () => this._saveRecordedRoute()); document.getElementById('discard-route-btn').addEventListener('click', () => this._discardRecordedRoute()); document.getElementById('search-submit-btn').addEventListener('click', () => this.searchLocation()); document.getElementById('import-routes-btn').addEventListener('click', () => this.importRoutes()); document.getElementById('export-routes-btn').addEventListener('click', () => this.exportRoutes()); document.getElementById('search-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') this.searchLocation(); }); }
        _showModal(modalName) { this.elements.modals[modalName].classList.add('visible'); }
        _hideModal(modalName) { this.elements.modals[modalName].classList.remove('visible'); }
        showNotification(message, type = 'info') { const notification = document.createElement('div'); notification.className = `notification ${type}`; notification.textContent = message; this.elements.notifications.appendChild(notification); setTimeout(() => notification.remove(), 3000); }
        updateCoordinates(latlng) { const lat = latlng.lat.toFixed(5); const lng = latlng.lng.toFixed(5); const mgrs = this.services.coordinator.toMGRS(latlng.lat, latlng.lng); this.elements.coordsDisplay.innerHTML = `Lat/Lon: ${lat}, ${lng}<br>MGRS: ${mgrs}`; }
        toggleTheme(forceTheme = null) { const isDark = forceTheme ? forceTheme === 'dark' : !document.body.hasAttribute('data-theme'); document.body.setAttribute('data-theme', isDark ? 'dark' : ''); if(!isDark) document.body.removeAttribute('data-theme'); this.elements.buttons.theme.querySelector('i').className = isDark ? 'fa-solid fa-sun' : 'fa-solid fa-moon'; localStorage.setItem('theme', isDark ? 'dark' : 'light'); if (isDark) { if (!this.map.hasLayer(this.layers.base["Супутник"])) this.map.addLayer(this.layers.base["Супутник"]); if (this.map.hasLayer(this.layers.base["Стандартна"])) this.map.removeLayer(this.layers.base["Стандартна"]); } else { if (!this.map.hasLayer(this.layers.base["Стандартна"])) this.map.addLayer(this.layers.base["Стандартна"]); if (this.map.hasLayer(this.layers.base["Супутник"])) this.map.removeLayer(this.layers.base["Супутник"]); } }
        loadTheme() { const savedTheme = localStorage.getItem('theme'); if (savedTheme) { this.toggleTheme(savedTheme); } }
        _setupDraggableButtons() { document.querySelectorAll('.action-button').forEach((btn, index) => { btn.style.top = `${15 + (index * 60)}px`; btn.style.right = '15px'; this._makeDraggable(btn); }); }
        _makeDraggable(element) { let isDragging = false, wasDragged = false, startX, startY, offsetX, offsetY; const onDown = (e) => { isDragging = true; wasDragged = false; element.classList.add('grabbing'); const event = e.touches ? e.touches[0] : e; startX = event.clientX; startY = event.clientY; const rect = element.getBoundingClientRect(); offsetX = event.clientX - rect.left; offsetY = event.clientY - rect.top; window.addEventListener('mousemove', onMove); window.addEventListener('touchmove', onMove); window.addEventListener('mouseup', onUp); window.addEventListener('touchend', onUp); }; const onMove = (e) => { if (!isDragging) return; const event = e.touches ? e.touches[0] : e; if (!wasDragged && (Math.abs(event.clientX - startX) > 5 || Math.abs(event.clientY - startY) > 5)) { wasDragged = true; } element.style.left = `${event.clientX - offsetX}px`; element.style.top = `${event.clientY - offsetY}px`; element.style.right = 'auto'; }; const onUp = () => { isDragging = false; element.classList.remove('grabbing'); window.removeEventListener('mousemove', onMove); window.removeEventListener('touchmove', onMove); window.removeEventListener('mouseup', onUp); window.removeEventListener('touchend', onUp); }; element.addEventListener('click', e => { if (wasDragged) { e.preventDefault(); e.stopPropagation(); } }, true); element.addEventListener('mousedown', onDown); element.addEventListener('touchstart', onDown); }
        _setupPWA() { window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); this.state.deferredPrompt = e; this.elements.buttons.install.style.display = 'flex'; }); window.addEventListener('appinstalled', () => { this.state.deferredPrompt = null; this.showNotification('Додаток успішно встановлено!', 'success'); }); }
        async _installPWA() { if (this.state.deferredPrompt) { this.state.deferredPrompt.prompt(); const { outcome } = await this.state.deferredPrompt.userChoice; if (outcome === 'accepted') { this.elements.buttons.install.style.display = 'none'; } this.state.deferredPrompt = null; } }
        _getGpsLocation() { if (!navigator.geolocation) { this.showNotification("Геолокація не підтримується вашим браузером", "error"); return; } navigator.geolocation.getCurrentPosition( pos => { const latlng = [pos.coords.latitude, pos.coords.longitude]; this.map.flyTo(latlng, 15); L.marker(latlng).addTo(this.map).bindPopup("Ваше поточне місцезнаходження").openPopup(); this.showNotification("Місцезнаходження знайдено", "success"); }, error => { let message = "Помилка отримання GPS-координат"; switch(error.code) { case error.PERMISSION_DENIED: message = "Доступ до геолокації відхилено"; break; case error.POSITION_UNAVAILABLE: message = "Інформація про місцезнаходження недоступна"; break; case error.TIMEOUT: message = "Час очікування геолокації вийшов"; break; } this.showNotification(message, "error"); }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 } ); }
        toggleRecording() { this.state.isRecording = !this.state.isRecording; const button = this.elements.buttons.record; button.classList.toggle('recording', this.state.isRecording); button.querySelector('i').className = this.state.isRecording ? 'fa-solid fa-stop' : 'fa-solid fa-route'; if (this.state.isRecording) { this.services.recording.points = []; this.services.recording.tempLayer.clearLayers(); this.services.recording.watchId = navigator.geolocation.watchPosition(pos => { const latlng = L.latLng(pos.coords.latitude, pos.coords.longitude); this.services.recording.points.push(latlng); if (this.services.recording.points.length > 1) { L.polyline(this.services.recording.points, { color: 'var(--record-color)', weight: 4 }).addTo(this.services.recording.tempLayer); } }, null, { enableHighAccuracy: true }); this.showNotification("Запис треку розпочато"); } else { if (this.services.recording.watchId) { navigator.geolocation.clearWatch(this.services.recording.watchId); } if (this.services.recording.points.length > 1) { const coords = this.services.recording.points.map(p => [p.lng, p.lat]); const distance = turf.length(turf.lineString(coords), { units: 'kilometers' }); document.getElementById('route-distance-display').textContent = `${distance.toFixed(2)} km`; document.getElementById('route-name-input').value = `Маршрут ${new Date().toLocaleString('uk-UA')}`; this._showModal('saveRoute'); } else { this.services.recording.tempLayer.clearLayers(); } this.showNotification("Запис треку зупинено"); } }
        _saveRecordedRoute() { const name = document.getElementById('route-name-input').value.trim(); if (!name) { this.showNotification('Введіть назву маршруту', 'warning'); return; } const color = document.getElementById('route-color-picker').value; const distance = parseFloat(document.getElementById('route-distance-display').textContent); const newRoute = { id: Date.now(), name, color, distance, latlngs: this.services.recording.points }; this.services.routes.push(newRoute); localStorage.setItem('savedRoutes', JSON.stringify(this.services.routes)); this.loadSavedRoutes(); this._hideModal('saveRoute'); this.services.recording.tempLayer.clearLayers(); this.showNotification(`Маршрут "${name}" збережено!`, 'success'); }
        _discardRecordedRoute() { this.services.recording.tempLayer.clearLayers(); this.services.recording.points = []; this._hideModal('saveRoute'); this.showNotification("Маршрут скасовано", "info"); }
        loadSavedRoutes() { this.layers.savedRoutes.clearLayers(); const routeListContainer = document.getElementById('route-list'); routeListContainer.innerHTML = ''; if (this.services.routes.length === 0) { routeListContainer.innerHTML = '<p>Збережених маршрутів немає.</p>'; return; } this.services.routes.forEach(route => { const routeLine = L.polyline(route.latlngs, { color: route.color || '#007aff', weight: 4, opacity: 0.8 }).addTo(this.layers.savedRoutes); routeLine.bindPopup(`<b>${route.name}</b><br>Дистанція: ${route.distance.toFixed(2)} км<br>Точок: ${route.latlngs.length}`); const listItem = document.createElement('div'); listItem.className = 'list-item'; listItem.innerHTML = `<span>${route.name} (${route.distance.toFixed(2)} км)</span><div class="list-item-actions"><button data-id="${route.id}" title="Видалити">&times;</button></div>`; listItem.addEventListener('click', (e) => { if (e.target.tagName !== 'BUTTON') { this.map.fitBounds(routeLine.getBounds()); routeLine.openPopup(); } }); listItem.querySelector('button').addEventListener('click', (e) => { e.stopPropagation(); this.deleteRoute(route.id); }); routeListContainer.appendChild(listItem); }); }
        deleteRoute(id) { if (!confirm("Ви впевнені, що хочете видалити цей маршрут?")) return; this.services.routes = this.services.routes.filter(r => r.id !== id); localStorage.setItem('savedRoutes', JSON.stringify(this.services.routes)); this.loadSavedRoutes(); this.showNotification("Маршрут видалено", "success"); }
        exportRoutes() { if (this.services.routes.length === 0) { this.showNotification("Немає маршрутів для експорту", "warning"); return; } const dataStr = JSON.stringify(this.services.routes, null, 2); const blob = new Blob([dataStr], {type: "application/json"}); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.download = "routes_" + new Date().toISOString().split('T')[0] + ".json"; link.href = url; link.click(); URL.revokeObjectURL(url); this.showNotification("Маршрути експортовано", "success"); }
        importRoutes() { const input = document.createElement('input'); input.type = 'file'; input.accept = '.json'; input.onchange = e => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = event => { try { const importedRoutes = JSON.parse(event.target.result); if (Array.isArray(importedRoutes)) { this.services.routes = [...this.services.routes, ...importedRoutes]; localStorage.setItem('savedRoutes', JSON.stringify(this.services.routes)); this.loadSavedRoutes(); this.showNotification(`Імпортовано ${importedRoutes.length} маршрутів`, "success"); } else { this.showNotification("Невірний формат файлу", "error"); } } catch (err) { this.showNotification("Помилка імпорту файлу", "error"); } }; reader.readAsText(file); }; input.click(); }
        async searchLocation() { const query = document.getElementById('search-input').value.trim(); const resultsContainer = document.getElementById('search-results'); if (!query) { this.showNotification("Введіть пошуковий запит", "warning"); return; } resultsContainer.innerHTML = 'Пошук...'; const coords = this.services.coordinator.parse(query); if (coords) { this.map.flyTo([coords.lat, coords.lng], 15); L.marker([coords.lat, coords.lng]).addTo(this.map).bindPopup(`Знайдено: ${query}`).openPopup(); this._hideModal('search'); this.showNotification(`Координати знайдено: ${coords.lat.toFixed(5)}, ${coords.lng.toFixed(5)}`, "success"); return; } try { const response = await fetch( `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=10&addressdetails=1` ); const data = await response.json(); resultsContainer.innerHTML = ''; if (data.length === 0) { resultsContainer.innerHTML = 'Нічого не знайдено.'; return; } data.forEach(item => { const resultEl = document.createElement('div'); resultEl.className = 'list-item'; resultEl.innerHTML = `<div><strong>${item.display_name}</strong><div style="font-size: 12px; color: #666;">${item.lat}, ${item.lon}</div></div>`; resultEl.onclick = () => { const latlng = [parseFloat(item.lat), parseFloat(item.lon)]; this.map.flyTo(latlng, 15); L.marker(latlng).addTo(this.map).bindPopup(`<b>${item.display_name}</b>`).openPopup(); this._hideModal('search'); this.showNotification(`Місце знайдено: ${item.display_name}`, "success"); }; resultsContainer.appendChild(resultEl); }); } catch (e) { resultsContainer.innerHTML = 'Помилка пошуку.'; console.error('Search error:', e); } }
        async _fetchSunriseSunset(lat, lng) { try { const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&daily=sunrise,sunset&timezone=auto&forecast_days=1`); if (!response.ok) throw new Error('Network response was not ok'); const data = await response.json(); return { sunrise: new Date(data.daily.sunrise[0]), sunset: new Date(data.daily.sunset[0]), }; } catch (error) { console.error('Sunrise/Sunset fetch error:', error); this.showNotification("Не вдалося завантажити час сходу сонця", "error"); return null; } }
        async _fetchRouteWeather(lat, lng) { try { const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&hourly=temperature_2m,precipitation_probability,weather_code&timezone=auto`); if (!response.ok) throw new Error('Weather fetch failed'); const data = await response.json(); return data; } catch (error) { console.error("Route weather error:", error); this.showNotification("Помилка завантаження прогнозу", "error"); return null; } }
        async showWeather() { this._showModal('weather'); const detailsContainer = document.getElementById('weather-details'); detailsContainer.innerHTML = 'Завантаження погоди...'; const center = this.map.getCenter(); const sunTimes = await this._fetchSunriseSunset(center.lat, center.lng); try { const response = await fetch( `https://api.open-meteo.com/v1/forecast?latitude=${center.lat}&longitude=${center.lng}&current=temperature_2m,weather_code,wind_speed_10m,relative_humidity_2m&timezone=auto&forecast_days=1` ); if (!response.ok) throw new Error('Network response was not ok'); const data = await response.json(); const weatherCodes = { 0: 'Ясно', 1: 'Переважно ясно', 2: 'Мінлива хмарність', 3: 'Хмарно', 45: 'Туман', 48: 'Туман з інеєм', 51: 'Мряка: легка', 53: 'Мряка: помірна', 55: 'Мряка: густа', 61: 'Дощ: легкий', 63: 'Дощ: помірний', 65: 'Дощ: сильний', 80: 'Злива: легка', 81: 'Злива: помірна', 82: 'Злива: сильна' }; const weatherDescription = weatherCodes[data.current.weather_code] || 'Невідомо'; const weatherHTML = ` <p><strong>Становище:</strong> ${weatherDescription}</p> <p><strong>Температура:</strong> ${data.current.temperature_2m}°C</p> <p><strong>Вологість:</strong> ${data.current.relative_humidity_2m}%</p> <p><strong>Вітер:</strong> ${data.current.wind_speed_10m} км/год</p> <p><strong>Схід сонця:</strong> ${sunTimes ? sunTimes.sunrise.toLocaleTimeString('uk-UA') : 'Н/Д'}</p> <p><strong>Захід сонця:</strong> ${sunTimes ? sunTimes.sunset.toLocaleTimeString('uk-UA') : 'Н/Д'}</p> <p><em>Координати: ${center.lat.toFixed(4)}, ${center.lng.toFixed(4)}</em></p> `; detailsContainer.innerHTML = weatherHTML; } catch (error) { detailsContainer.innerHTML = 'Не вдалося завантажити погоду.'; console.error('Weather error:', error); } }
        togglePlanning() { this.state.isPlanning = !this.state.isPlanning; const button = document.getElementById('plan-btn'); button.classList.toggle('active', this.state.isPlanning); this.map.getContainer().classList.toggle('map-routing-mode', this.state.isPlanning); if(this.state.isPlanning) { this.services.planning.waypoints = []; if(this.services.planning.control) { this.map.removeControl(this.services.planning.control); } this.layers.mortarRange.clearLayers(); this.map.on('click', this._handlePlanningClick, this); this.showNotification("Клікніть на карті, щоб встановити початкову точку"); } else { this.map.off('click', this._handlePlanningClick, this); this.showNotification("Режим планування вимкнено"); } }
        _handlePlanningClick(e) { this.services.planning.waypoints.push(e.latlng); L.marker(e.latlng, { icon: L.divIcon({ className: 'planning-marker', html: `<div style="background: var(--accent-color); color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px;">${this.services.planning.waypoints.length}</div>`, iconSize: [20, 20] }) }).addTo(this.layers.mortarRange); if (this.services.planning.waypoints.length === 1) { this.showNotification("Тепер клікніть, щоб встановити кінцеву точку"); } if (this.services.planning.waypoints.length === 2) { this.services.planning.control = L.Routing.control({ waypoints: this.services.planning.waypoints, createMarker: () => null, show: false, lineOptions: { styles: [{color: 'var(--accent-color)', opacity: 0.8, weight: 6}], extendToWaypoints: true, missingRouteTolerance: 10 }, routeWhileDragging: true, showAlternatives: false }).addTo(this.map); this.services.planning.control.on('routesfound', e => { const route = e.routes[0]; const coords = route.coordinates.map(c => [c.lng, c.lat]); this._calculateAndDrawMortarRange(coords, 400, 3500); this.showNotification(`Маршрут побудовано. Дистанція: ${(route.summary.totalDistance / 1000).toFixed(2)} км`); }); this.services.planning.control.on('routingerror', e => { this.showNotification("Помилка побудови маршруту", "error"); }); this.togglePlanning(); } }
        _calculateAndDrawMortarRange(coords, min, max) { try { const routeLine = turf.lineString(coords); const maxBuffer = turf.buffer(routeLine, max, { units: 'meters' }); const minBuffer = turf.buffer(routeLine, min, { units: 'meters' }); const effectiveZone = turf.difference(maxBuffer, minBuffer); L.geoJSON(effectiveZone, { style: { color: "#ff4747", weight: 2, opacity: 0.7, fillColor: "#ff4747", fillOpacity: 0.3 } }).addTo(this.layers.mortarRange).bindPopup(`Зона ураження<br>Дальність: ${min}-${max} м`); } catch (e) { console.error("Помилка розрахунку зони ураження:", e); this.showNotification("Помилка розрахунку зони ураження", "error"); } }

        toggleNavigation() {
            this.state.isNavigating = !this.state.isNavigating;
            const button = document.getElementById('navigate-btn');
            button.classList.toggle('navigating', this.state.isNavigating);
             
            if(this.state.isNavigating) {
                this.map.getContainer().classList.add('map-navigation-mode');
                this.showNotification("Клікніть на карті, щоб обрати пункт призначення");
                
                this.map.once('click', (e) => {
                    this.map.getContainer().classList.remove('map-navigation-mode');
                    const destination = e.latlng;

                    navigator.geolocation.getCurrentPosition(async (pos) => {
                        const start = L.latLng(pos.coords.latitude, pos.coords.longitude);
                        
                        this.elements.navInfoPanel.innerHTML = `<span>Завантаження...</span>`;
                        this.elements.navInfoPanel.classList.add('visible');

                        const sunTimes = await this._fetchSunriseSunset(start.lat, start.lng);
                        this.state.sunriseTime = sunTimes ? sunTimes.sunrise : null;
                        this.state.sunsetTime = sunTimes ? sunTimes.sunset : null;
                        this.state.routeWeather = await this._fetchRouteWeather(destination.lat, destination.lng);

                        this.services.navigation.control = L.Routing.control({ waypoints: [start, destination], routeWhileDragging: true, showAlternatives: false, lineOptions: { styles: [{color: 'var(--navigation-color)', opacity: 0.8, weight: 6}] } }).addTo(this.map);
                        this.services.navigation.control.on('routesfound', e => { this.services.navigation.oneWayDistance = e.routes[0].summary.totalDistance; });
                        this.services.navigation.control.on('routingerror', () => { this.showNotification("Помилка побудови маршруту", "error"); this.toggleNavigation(); });
                        this.services.navigation.marker = L.circleMarker(start, { radius: 8, color: 'var(--navigation-color)', fillColor: 'var(--navigation-color)', fillOpacity: 0.8 }).addTo(this.map);
                        this.map.flyTo(start, 16);
                        
                        this.services.navigation.watchId = navigator.geolocation.watchPosition(
                            pos => {
                                const newLatLng = L.latLng(pos.coords.latitude, pos.coords.longitude);
                                this.services.navigation.marker.setLatLng(newLatLng);
                                this.services.navigation.control.spliceWaypoints(0, 1, newLatLng);
                                this.services.navigation.lastKnownSpeed = pos.coords.speed;
                                this._updateNavPanel(pos.coords.speed); 
                            },
                            () => this.showNotification("Помилка оновлення позиції", "error"),
                            { enableHighAccuracy: true }
                        );
                        
                    }, () => { this.showNotification("Не вдалося отримати вашу геолокацію", "error"); this.toggleNavigation(); });
                });
            } else {
                this.map.getContainer().classList.remove('map-navigation-mode');
                this.map.off('click');
                if (this.services.navigation.watchId) navigator.geolocation.clearWatch(this.services.navigation.watchId);
                if (this.services.navigation.control) this.map.removeControl(this.services.navigation.control);
                if (this.services.navigation.marker) this.map.removeLayer(this.services.navigation.marker);
                
                this.elements.navInfoPanel.classList.remove('visible');
                this.services.navigation = { watchId: null, control: null, marker: null, oneWayDistance: 0, lastKnownSpeed: 0 };
                this.state.sunriseTime = null;
                this.state.sunsetTime = null;
                this.state.routeWeather = null;
                this.state.etaTarget = 'sunrise';
                this.showNotification("Навігацію вимкнено");
            }
        }
        
        // === ИЗМЕНЕНИЕ: Добавлен расчет рекомендуемой скорости ===
        _updateNavPanel(speedInMps) {
            const speed = speedInMps || 0;
            const speedKmh = (speed * 3.6).toFixed(1);
            
            let weatherHtml = 'Погода: Н/Д';
            const oneWayDistance = this.services.navigation.oneWayDistance || 0;
            if (this.state.routeWeather && speed > 0.5) {
                const timeToOneWayArrivalSeconds = oneWayDistance / speed;
                const arrivalDate = new Date(Date.now() + timeToOneWayArrivalSeconds * 1000);
                const arrivalHour = arrivalDate.getHours();
                const arrivalDateString = arrivalDate.toISOString().substring(0, 10);
                const weatherCodes = {0:"☀️",1:"🌤️",2:"🌥️",3:"☁️",45:"🌫️",48:"🌫️",51:"🌧️",53:"🌧️",55:"🌧️",61:"🌧️",63:"🌧️",65:"🌧️",80:"🌧️",81:"🌧️",82:"🌧️"};
                try {
                    const timeIndex = this.state.routeWeather.hourly.time.findIndex(t => t.startsWith(`${arrivalDateString}T${String(arrivalHour).padStart(2, '0')}`));
                    if (timeIndex !== -1) {
                        const code = this.state.routeWeather.hourly.weather_code[timeIndex];
                        const temp = Math.round(this.state.routeWeather.hourly.temperature_2m[timeIndex]);
                        const precip = this.state.routeWeather.hourly.precipitation_probability[timeIndex];
                        weatherHtml = `<div id="arrival-weather" title="Прогноз на час прибуття"><span>${weatherCodes[code] || '❓'}</span> ${temp}°C | ${precip}% 💧</div>`;
                    }
                } catch(e) { /* Игнорируем ошибку */ }
            }

            const targetTime = this.state.etaTarget === 'sunrise' ? this.state.sunriseTime : this.state.sunsetTime;
            const targetLabel = this.state.etaTarget === 'sunrise' ? 'сходу' : 'заходу';
            let etaHtml = '';
            let suggestedSpeedHtml = ''; // Для рекомендуемой скорости

            if (!targetTime) {
                etaHtml = `🌅 Час ${targetLabel} невідомий`;
            } else {
                const roundTripDistance = oneWayDistance * 2;
                const timeRemainingSeconds = (targetTime.getTime() - Date.now()) / 1000;

                if (speed < 0.5) {
                    etaHtml = `туди й назад: ${(roundTripDistance / 1000).toFixed(2)} км`;
                } else {
                    const timeToArrivalSeconds = roundTripDistance / speed;
                    const returnDate = new Date(Date.now() + timeToArrivalSeconds * 1000);
                    const timeDiff = targetTime.getTime() - returnDate.getTime();
                    const formatDiff = (ms) => {
                        const totalSeconds = Math.abs(Math.floor(ms / 1000));
                        const hours = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
                        const minutes = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
                        return `${hours}:${minutes}`;
                    };
                    
                    if (timeDiff > 0) {
                        etaHtml = `✅ Встигнете до ${targetLabel} (запас: ${formatDiff(timeDiff)})`;
                    } else {
                        etaHtml = `❌ Запізнення до ${targetLabel}: ${formatDiff(timeDiff)}`;
                        // Расчет рекомендуемой скорости, если опаздываем и еще есть время
                        if (timeRemainingSeconds > 0) {
                            const requiredSpeedMs = roundTripDistance / timeRemainingSeconds;
                            const requiredSpeedKmh = (requiredSpeedMs * 3.6).toFixed(1);
                            suggestedSpeedHtml = `<span class="separator"></span> <span title="Потрібна середня швидкість">🏃 ${requiredSpeedKmh} км/год</span>`;
                        }
                    }
                }
            }
            
            const toggleIcon = this.state.etaTarget === 'sunrise' ? '🌇' : '🌅';
            
            this.elements.navInfoPanel.innerHTML = `
                <div class="eta-info">${weatherHtml}</div>
                <div class="separator"></div>
                <div class="eta-info">🚀 ${speedKmh} км/год</div>
                <div class="separator"></div>
                <div class="eta-info">${etaHtml}${suggestedSpeedHtml}</div>
                <button id="eta-toggle-btn" title="Переключити на захід/схід сонця">${toggleIcon}</button>
            `;
            
            document.getElementById('eta-toggle-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                this.state.etaTarget = this.state.etaTarget === 'sunrise' ? 'sunset' : 'sunrise';
                this._updateNavPanel(this.services.navigation.lastKnownSpeed);
            });
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const app = new TacticalNavigator();
        app.init();
        window.app = app;
    });
    </script>
</body>
</html>
